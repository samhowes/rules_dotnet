# Build Explanation 


## Core Compile Process

rules_dotnet rules collect build inputs provided from the `srcs` and `deps` attributes and ultimately pass them to `csc.exe` mimicking msbuild as much as possible [(see emit_assembly_core_csharp)](../dotnet/private/actions/assembly_core.bzl#L76) 

Rules compile to standalone executables using [/nostdlib+](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/nostdlib-compiler-option). One notable impact of this is all possibly referenced system dlls are copied into the build output directory next to the target assembly. [See Runtime considerations](./runtime.md). This results in *many* more .dlls in the output directory than a standard call to `dotnet build`.

## Output

Output for the command `bazel build //foo/bar:bar.exe` given an input target defined in `<workspaceroot>/foo/bar/BUILD` as:
``` python 
# <workspaceroot>/foo/bar/BUILD
csharp_binary(
    name = "bar.exe",
    srcs = ["Program.cs"],
    deps = ["@core_sdk_stdlib//:libraryset"]
)
```

- [`<workspaceroot>/bazel-bin/foo/` (symlink)](https://docs.bazel.build/versions/4.0.0/output_directories.html#layout-diagram)
  - `bar.exe.param` These are the parameters passed to csc.exe by [emit_assembly_core_csharp](../dotnet/private/actions/assembly_core.bzl#L170) to compile `bazel-bin/foo/bar.exe/bar.exe`
  - `bar.exe/` (yes, this is a folder)
    - `bar.exe_0.exe`: can be executed directly: `./bar.exe_0.exe` 
    - `bar.exe`: can be executed with: `dotnet bar.exe`
      - May produce an error regarding `bar.deps.json` not existing
    - `bar.exe_0.exe.runfiles`: todo(samhowes): explain(runfiles)
    - `bar.exe_0.exe.runfiles_manifest`
    - *many* system dlls
    - nuget dependencies


### Justification for `exe_0`
todo(samhowes): explain(exe_0)


##  StdLib

As mentioned [above](#Core_Compile_Process), csc.exe is called directly, bypassing `dotnet` and `msbuild`. Because of this, csc does't know what any of the standard libraries are. As such, the standard libraries need to be listed in the `deps` attribute of a target. (For understanding deps compared to csproj, see [Migrating from MsBuild](./migrating_from_msbuild.md#Deps))

### Acquiring and defining dependencies
`rules_dotnet` defines .NET Framework Sdks as [external workspace dependencies](https://docs.bazel.build/versions/4.0.0/be/workspace.html#workspace-rules). The [`macro`](https://docs.bazel.build/versions/master/skylark/macros.html#macros) [`dotnet_repositories`](https://github.com/bazelbuild/rules_dotnet/blob/master/dotnet/private/repositories.bzl#L15) defines labels to [`download_and_extract`](https://github.com/bazelbuild/rules_dotnet/blob/master/dotnet/private/sdk_core.bzl#L26) the [supported dotnet sdks](https://github.com/bazelbuild/rules_dotnet/blob/master/dotnet/platform/list.bzl#L1) based on a provided [platform and toolchain](https://docs.bazel.build/versions/master/platforms-intro.html). This rule will download and extract the sdk assemblies into `core_sdk_{os}_{arch}_{sdk}` in the `external` folder of your workspace's [`outputBase`](https://docs.bazel.build/versions/4.0.0/output_directories.html#layout-diagram) i.e. `~/_bazel_$USER/<hash>/external/core_sdk_windows_amd64_3.1.100`. The [`repository_rule`](https://docs.bazel.build/versions/master/skylark/repository_rules.html#repository-rule-creation) [`core_stdlib`](https://github.com/bazelbuild/rules_dotnet/blob/master/dotnet/private/repositories.bzl#L60) (called by `dotnet_repositories()`) provides a layer of indirection to the downloaded `core_sdk_{os}_{arch}_{sdk}` by defining an external worksapce `@core_sdk_stdlib` that simply contains aliases to the appropriate sdk target for the *current invocation* of bazel.

So far, the assemblies have been downloaded, but we have not yet told Bazel how to use the actual assemblies themselves. [`core_download_sdk`](https://github.com/bazelbuild/rules_dotnet/blob/master/dotnet/private/sdk_core.bzl#L3), after downloading the assemblies, calls `_sdk_build_file` which tells bazel via [`ctx.template()`](https://docs.bazel.build/versions/master/skylark/rules-tutorial.html#create-a-file-with-a-template) to create `core_sdk_{os}_{arch}_{sdk}/BUILD.bazel` from the template file [`BUILD.core.bazel`](https://github.com/bazelbuild/rules_dotnet/blob/master/dotnet/private/BUILD.core.bazel). This templated build file creates file informs bazel about the downloaded `csc.exe` and `fsc.exe` via [`filegroup`](https://docs.bazel.build/versions/master/be/general.html#filegroup) and finally calls `define_stdlib` and `define_runtime` from the appropriate `.bzl` file in `@io_bazel_rules_dotnet//dotnet/private:stdlib/{sdk}(-runtime).bzl`. These files, generated by [`StdlibCoreGenerator3.cs`](https://github.com/bazelbuild/rules_dotnet/blob/master/tools/nuget2bazel/rules/StdlibCoreGenerator3.cs#L45), define the actual labels for using the downloaded assemblies.

### Example usage
This enables the following standardized setup:

BUILD File
``` python 
# <workspaceroot>/foo/bar/BUILD
load("@io_bazel_rules_dotnet//dotnet:defs.bzl", "csharp_binary")
csharp_binary(
    name = "bar.exe",
    srcs = ["Program.cs"],
    deps = ["@core_sdk_stdlib//:libraryset"]
)
```

WORKSPACE File
``` python
load("@io_bazel_rules_dotnet//dotnet:deps.bzl", "dotnet_repositories")
dotnet_repositories()
load(
    "@io_bazel_rules_dotnet//dotnet:defs.bzl",
    "dotnet_register_toolchains",
    "dotnet_repositories_nugets",
)
dotnet_register_toolchains()
dotnet_repositories_nugets()
```

.bazelrc
``` bash
build --host_platform @io_bazel_rules_dotnet//dotnet/toolchain:windows_amd64_3.1.100
build --platforms @io_bazel_rules_dotnet//dotnet/toolchain:windows_amd64_3.1.100
```

Invoking `bazel build //foo/bar:bar.exe` will:
1. Download the [.NET Core 3.1.0 Sdk](https://github.com/dotnet/core/blob/master/release-notes/3.1/3.1.0/3.1.0.md) into `~/_bazel_$USER/<hash>/external/core_sdk_windows_amd64_3.1.100`
2. Generate a BUILD file defining labels for the downloaded assemblies
3. Create `~/_bazel_$USER/<hash>/external/core_sdk_stdlib` with a WORKSPACE and a BUILD file referencing the previous download

The required assemblies can now be copied into bin directory for compilation and linking.

## Generation of System Assemblies
todo(samhowes): explain(StdlibCoreGenerator3.cs)


## Unit Test Rules
Test rules depend on the [nuget packages](../dotnet/private/deps/nuget.bzl).


# Tweaks to other docs

## Setup of .bazelrc
```
build --host_platform @io_bazel_rules_dotnet//dotnet/toolchain:windows_amd64_3.1.100
build --platforms @io_bazel_rules_dotnet//dotnet/toolchain:windows_amd64_3.1.100
```

## Reccommended way to register a nuget package with bazel
```powershell
mkdir <workspaceroot>/deps/nuget.bzl
touch <workspaceroot>/deps/BUILD
```

`<workspaceroot>/deps/nuget.bzl`
```python
"""Defines nuget pacakges for the workspace"""
load("@io_bazel_rules_dotnet//dotnet:defs.bzl", "nuget_package")

def nuget_packages():
    return 
```
`<workspaceroot>/WORKSPACE`
```python
load("//deps:nuget.bzl", "nuget_packages")
nuget_packages()
```

```powershell
bazel run @io_bazel_rules_dotnet//tools/nuget2bazel:nuget2bazel.exe -- add -p $PWD CommandLineParser 2.6.0 -b deps/nuget.bzl -i 
```

> **Side Effect**: this command creates a `packages` folder in the current directory. I'm not sure if this is required by NuGet or not. It may be safely deleted.


`@commandlineparser//:lib` may now be listed as a dependency of a target for access to the nuget package.

`<workspaceroot>/foo/bar/BUILD`
``` python
load("@io_bazel_rules_dotnet//dotnet:defs.bzl", "csharp_binary")

csharp_binary(
    name = "bar.exe",
    srcs = [
        "Program.cs",
    ],
    deps = [
        "@core_sdk_stdlib//:libraryset",
        "@commandlineparser//:lib"
    ],
)

```

## Multiple NuGet Versions

> NOTE: Bazel recommends a [single version policy](https://docs.bazel.build/versions/master/external.html#shadowing-dependencies) for your project.

If you need to manage multiple versions of a NuGet Package, nuget2bazel supports this with the -v option.